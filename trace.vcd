$version Generated by VerilatedVcd $end
$date Mon Aug 17 22:19:22 2020
 $end
$timescale 100ps $end

 $scope module TOP $end
  $var wire  1 I CLK $end
  $var wire  1 N GPIO11 $end
  $var wire  1 L GPIO3 $end
  $var wire  1 M GPIO9 $end
  $var wire  1 J RX $end
  $var wire  1 K TX $end
  $scope module top $end
   $var wire  1 I CLK $end
   $var wire  1 N GPIO11 $end
   $var wire  1 L GPIO3 $end
   $var wire  1 M GPIO9 $end
   $var wire  1 J RX $end
   $var wire  8 # RXbuffer [7:0] $end
   $var wire  1 $ RXready $end
   $var wire  1 K TX $end
   $var wire  8 O TXbuffer [7:0] $end
   $var wire  1 % TXbusy $end
   $var wire  1 P TXstart $end
   $var wire  3 Q a [2:0] $end
   $var wire  3 ' aluOperand1 [2:0] $end
   $var wire  3 Q aluOperand2 [2:0] $end
   $var wire  6 ) aluOperation [5:0] $end
   $var wire 16 A aluOut [15:0] $end
   $var wire  4 * aluParams [3:0] $end
   $var wire  1 + aluReadBus $end
   $var wire  3 ( aluResults [2:0] $end
   $var wire 16 X apuOut [15:0] $end
   $var wire  3 \ b [2:0] $end
   $var wire 16 B bus [15:0] $end
   $var wire  4 & busState [3:0] $end
   $var wire 16 Y clkOut [15:0] $end
   $var wire 25 7 clkdiv [24:0] $end
   $var wire 16 S ctrlOut [15:0] $end
   $var wire 16 Z din [15:0] $end
   $var wire 16 [ dout [15:0] $end
   $var wire 16 W gpuOut [15:0] $end
   $var wire 16 5 greg [15:0] $end
   $var wire 16 R hreg [15:0] $end
   $var wire  6 ] operation [5:0] $end
   $var wire  1 6 overflow $end
   $var wire  4 ^ params [3:0] $end
   $var wire 16 S ramAddress [15:0] $end
   $var wire 16 U ramOut [15:0] $end
   $var wire  1 P ramWrite $end
   $var wire 16 T romAddress [15:0] $end
   $var wire 16 V romOut [15:0] $end
   $var wire  4 ^ testState [3:0] $end
   $var wire  3 Q y [2:0] $end
   $scope module ALU $end
    $var wire  1 I CLK $end
    $var wire 16 9 a [15:0] $end
    $var wire 17 C addsub [16:0] $end
    $var wire 16 : b [15:0] $end
    $var wire 16 ; c [15:0] $end
    $var wire 16 H combOperand2 [15:0] $end
    $var wire 16 < d [15:0] $end
    $var wire 16 B din [15:0] $end
    $var wire 16 A dout [15:0] $end
    $var wire 16 = e [15:0] $end
    $var wire 16 > f [15:0] $end
    $var wire 16 5 g [15:0] $end
    $var wire 16 ? h [15:0] $end
    $var wire 16 E log [15:0] $end
    $var wire 16 F lshift [15:0] $end
    $var wire 17 D mult [16:0] $end
    $var wire 16 A operand1 [15:0] $end
    $var wire 16 @ operand2 [15:0] $end
    $var wire  3 ' operandIndex1 [2:0] $end
    $var wire  3 Q operandIndex2 [2:0] $end
    $var wire  6 ) operation [5:0] $end
    $var wire  1 6 overflow $end
    $var wire  4 * params [3:0] $end
    $var wire  1 + readBus $end
    $var wire  3 ( resultsIndex [2:0] $end
    $var wire 16 G rshift [15:0] $end
   $upscope $end
   $scope module CONTROL $end
    $var wire  1 I CLK $end
    $var wire  6 ) aluOperation [5:0] $end
    $var wire  4 * aluParams [3:0] $end
    $var wire  1 + aluReadBus $end
    $var wire  4 & busState [3:0] $end
    $var wire 32 ` controlWord [31:0] $end
    $var wire 16 S dout [15:0] $end
    $var wire 16 5 greg [15:0] $end
    $var wire 16 R hreg [15:0] $end
    $var wire  1 4 increment $end
    $var wire  6 a opcode [5:0] $end
    $var wire  3 ' operand1 [2:0] $end
    $var wire  3 Q operand1Wire [2:0] $end
    $var wire  3 Q operand2 [2:0] $end
    $var wire  3 Q operand2Wire [2:0] $end
    $var wire 16 8 programCounter [15:0] $end
    $var wire 16 S ramAdd [15:0] $end
    $var wire  1 P ramAddMode $end
    $var wire  1 P ramWrite $end
    $var wire  3 ( results [2:0] $end
    $var wire  3 Q resultsWire [2:0] $end
    $var wire 16 T romAdd [15:0] $end
    $var wire 16 S word2Wire [15:0] $end
   $upscope $end
   $scope module FTDI $end
    $var wire  1 I CLK $end
    $var wire 32 _ CLOCK_DIVISOR [31:0] $end
    $var wire  1 J RX $end
    $var wire  8 # RXbuffer [7:0] $end
    $var wire  1 $ RXready $end
    $var wire  4 1 RXstate [3:0] $end
    $var wire  1 K TX $end
    $var wire  8 O TXbuffer [7:0] $end
    $var wire  1 % TXbusy $end
    $var wire  1 / TXready $end
    $var wire  8 0 TXshift [7:0] $end
    $var wire  1 P TXstart $end
    $var wire  4 . TXstate [3:0] $end
    $var wire  3 , baudAcc [2:0] $end
    $var wire  1 - baudTick $end
    $var wire  3 2 gap [2:0] $end
    $var wire  1 3 nextBit $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#666
b00000000 #
0$
0%
b0000 &
b000 '
b000 (
b000000 )
b0000 *
0+
b000 ,
0-
b0000 .
1/
b00000000 0
b0000 1
b000 2
03
04
b0000000000000000 5
06
b0000000000000000000000000 7
b0000000000000000 8
b0000000000000010 9
b0000000000000000 :
b0000000000000000 ;
b0000000000000000 <
b0000000000000000 =
b0000000000000000 >
b0000000000000000 ?
b0000000000000010 @
b0000000000000010 A
b0000000000000000 B
b00000000000000100 C
b00000000000000100 D
b0000000000000010 E
b0000000000000010 F
b0000000000000010 G
b0000000000000010 H
0I
1J
1K
0L
1M
0N
b00000000 O
0P
b000 Q
b0000000000000000 R
b0000000000000100 S
b0000000000000000 T
b0000000000000000 U
b0000000000000000 V
b0000000000000000 W
b0000000000000000 X
b0000000000000000 Y
b0000000000000000 Z
b0000000000000000 [
b001 \
b000000 ]
b0000 ^
b00000000000000000000000000000010 _
b00000000000001000000000000001000 `
b001000 a
#833
b0000000000000000000000001 7
1I
#1250
b0110 &
b100001 )
1+
14
b0000000000000100 B
b00000000000000110 C
b00000000000001000 D
b0000000000000000 E
b0000000000000100 H
0I
#1499
#1666
b0000000000000000000000010 7
b0000000000000001 8
b0000000000000110 9
b0000000000000110 @
b0000000000000110 A
b00000000000001010 C
b00000000000011000 D
b0000000000000100 E
b0000000000000110 F
b0000000000000110 G
1I
#2083
0I
#2333
#2500
b0000000000000000000000011 7
b0000000000000010 8
b0000000000001010 9
b0000000000001010 @
b0000000000001010 A
b00000000000001110 C
b00000000000101000 D
b0000000000000000 E
b0000000000001010 F
b0000000000001010 G
1I
#2916
0I
